<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.7.1">
<meta name="author" content="Fatih BAKIR">
<title>Iterator invalidation</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
</head>
<body class="article">
<div id="header">
<h1>Iterator invalidation</h1>
<div class="details">
<span id="author" class="author">Fatih BAKIR</span><br>
<span id="email" class="email"><a href="mailto:bakir@ucsb.edu">bakir@ucsb.edu</a></span><br>
</div>
</div>
<div id="content">
<div class="paragraph">
<p>Iterator gecersizleme, omru bitmemis bir iterator&#8217;un gosterdigi nesnenin omrunun bitmesine denir. Gecersizlenmis iteratorlere <em>dangling</em> iterator de denir.</p>
</div>
<div class="paragraph">
<p>Pointer&#8217;lar icin de ayni durum gecerli olmakla <em>dangling pointer</em> belki de daha sik kullanilan bir terimdir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp"><span class="directive">void</span> foo()
{
        <span class="directive">auto</span> x = <span class="keyword">new</span> <span class="predefined-type">int</span>;
        <span class="keyword">delete</span> x;
        <span class="comment">// x bu noktada gecersiz</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu noktada onemli bir mevzu, C++'da iterator ve pointerlarin gosterdigi nesneyi <em>takip etmiyor</em> olusudur. Ustteki ornekte gecersizleme asikarken, daha gizli yollardan bu problemle karsilasabiliriz. Mesela <code>std::vector</code> gibi bitisik container tiplerinde eger alan onden <code>reserve</code> edilmemisse yeni bir eleman eklemek butun iteratorleri gecersizler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp"><span class="directive">void</span> foo()
{
        std::vector v{<span class="integer">3</span>, <span class="integer">5</span>, <span class="integer">7</span>, <span class="integer">9</span>}; <span class="comment">// C++17 template type deduction</span>

        <span class="directive">auto</span> it = v.begin() + <span class="integer">1</span>;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu koda gore, asagidakine benzer bir memory durumuna sahipiz:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="/assets/images/iterator_invalid1.png" alt="State" width="80%">
</div>
</div>
<div class="paragraph">
<p>Fakat vector&#8217;ümüze aşağıdaki gibi bir eleman daha eklersek, olan bütün elemanlar vector büyüdükten sonraki yere
taşınacak ve vector&#8217;ün orijinal yeri deallocate edilecek. Bu durumda, <code>it</code> hala vector&#8217;un eski elemanlarından birininin
bulunduğu yeri gösterdiği için, kendisine <em>sarkıyor</em> yani <em>danglind</em> diyoruz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="cpp">        v.push_back(<span class="integer">11</span>);
        <span class="comment">// it bu noktada dangle etmekte</span></code></pre>
</div>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="/assets/images/iterator_invalid2.png" alt="State" width="80%">
</div>
</div>
</div>
</body>
</html>