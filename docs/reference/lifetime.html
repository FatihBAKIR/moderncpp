<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<meta name="author" content="Fatih BAKIR">
<title>Lifetime</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
</head>
<body class="article">
<div id="header">
<h1>Lifetime</h1>
<div class="details">
<span id="author" class="author">Fatih BAKIR</span><br>
<span id="email" class="email"><a href="mailto:bakir@ucsb.edu">bakir@ucsb.edu</a></span><br>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_static_storage">1. Static storage</a></li>
<li><a href="#_thread_local_storage">2. Thread local storage</a></li>
<li><a href="#_automatic_storage">3. Automatic storage</a></li>
<li><a href="#_dynamic_storage">4. Dynamic storage</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Lifetime, yada object lifetime, C++'da bir nesnenin gecerli oldugu araliga denir.</p>
</div>
<div class="paragraph">
<p>C++ dilinde temel olarak 4 adet lifetime sinifi vardir ve basitce nesnelerin nerede <em>yasadigina</em> baglidir:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Static</p>
</li>
<li>
<p>Thread local</p>
</li>
<li>
<p>Automatic</p>
</li>
<li>
<p>Dynamic</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_static_storage">1. Static storage</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Her bir storage sinifinin farkli yasam sureleri vardir, ornegin <em>static storage</em>'a sahip bir nesnenin yasam suresi construct edildikten program bitene kadardir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>std::string hello = "merhaba dunya!";

int main()
{
	std::cout &lt;&lt; hello &lt;&lt; '\n';
}</pre>
</div>
</div>
<div class="paragraph">
<p>Yukaridaki <em>global</em> <code>hello</code> objesinin constructor&#8217;u main fonksyonundan once cagirilacak, destructor&#8217;u ise main bittikten sonra cagirilacak.</p>
</div>
<div class="paragraph">
<p>Static storage&#8217;a sahip nesneler global nesneler veya fonksyonlara ait <em>static</em> nesnelerdir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>int global_object = 5;

int foo()
{
	static int value = 42;
	return value;
}</pre>
</div>
</div>
<div class="paragraph">
<p>Ustteki ornekteki <code>value</code> ve <code>global_object</code> nesnelerinin ikisi de <em>static</em> storage&#8217;a sahiptir. Aralarindaki fark ise ne noktada <em>initialize</em> edildikleridir. Global nesneler main fonksyonu cagirilmadan once construct ediliyorken, fonksyon static nesneler o fonksyon ilk cagirildiginda construct edilir ve dolayisiyla o fonksyon hic cagirilmazsa, constructor ve dolayisiyla destructor&#8217;lari da asla cagirilmaz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>int main(int argc, char** argv)
{
    if (argc &gt; 1) foo();
}</pre>
</div>
</div>
<div class="paragraph">
<p>Ornegin, yukaridaki program tek bir arguman ile cagirilirsa, <code>value</code> objesi asla hayata baslamayacak.</p>
</div>
<div class="paragraph">
<p>Static storage&#8217;a ait nesneler dogrudan derlenen kutuphane yada uygulama icinde <em>static</em> memory&#8217;ye sahiptir. Dolayisiyla asla initialize edilmese bile, static storage&#8217;a sahip butun objeler en azindan virtual memory&#8217;de yer kaplar.</p>
</div>
<div class="paragraph">
<p>Onemli bir nokta, global degiskenlerin olusturulma ve yok edilme siralariyla ilgili bir garanti bulunmamasidir. Dolayisiyla, global nesnelerin constructor ve destructor&#8217;larinda diger global nesnelere ulasmak genellikle tehlikeli bir davranistir.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_thread_local_storage">2. Thread local storage</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>thread_local std::string val = "her thread icin farkli!";

void foo()
{
	thread_local std::string func_thread_local = "her thread icin yine farkli";
	//...
}</pre>
</div>
</div>
<div class="paragraph">
<p>Thread local storage pek cok acidan static storage&#8217;a benzer, hatta, static storage&#8217;i main thread&#8217;e ait thread local degiskenler gibi dusunebilirsiniz.</p>
</div>
<div class="paragraph">
<p>Isminden de anlasilacagi gibi, thread local nesneler global yada fonkyon statik nesneler gibi gorunseler de, her thread icin ayri ayri olusturulurlar. Bu storage&#8217;a sahip nesneler threadler arasindaki race conditionlari azaltmakta buyuk fayda saglarlar.</p>
</div>
<div class="paragraph">
<p>Static storage&#8217;a ait nesnelerden farkli olarak, main thread&#8217;e ait olmayan bu objelerin kullanacagi memory dinamik olarak alinir. Thread local objeler main thread icin de ulasilabilirdir fakat normal static storage&#8217;a sahip objeler gibi davranirlar.</p>
</div>
<div class="paragraph">
<p>Bir not olarak, genellikle <code>new</code> yada <code>malloc</code> kullanmak yerine threading kutuphanesinin sagladigi thread local desteginden yararlanirlar.</p>
</div>
<div class="paragraph">
<p>Thread local storage&#8217;a sahip butun nesneler, o nesnelere ait thread&#8217;in giris fonksyonu donus yada exception sebebiyle ciktigi zaman destruct edilir ve bu nesnelerle ilgili butun iterator ve pointer&#8217;lar <em>gecersizlenir</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_automatic_storage">3. Automatic storage</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Automatic storage, fonksyonlarin icindeki lokal degiskenlerin sahip oldugu storage tipidir. Bu nesnelerin yasamlari cevrelerindeki scope&#8217;la baslar, ve scope kapandiginda biter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>void foo()
{
	std::string foo; // foo'nun omru baslar

	for (int i = 0; i &lt; 5; ++i)
	{
		std::vector&lt;int&gt; vs; // vs'in omru baslar
		// vs'i kullan
	} // &lt;- vs'in omru biter
} // foo'nun omru biter</pre>
</div>
</div>
<div class="paragraph">
<p>Yukaridaki ornekte <code>foo</code> fonksyonun butun govdesinde hayatta iken, <code>vs</code> her dongude olusturulup yok edilir.</p>
</div>
<div class="paragraph">
<p>Genel olarak <em>stack variable</em> olarak adlandirilsalar da C++ bu degiskenlerin tam olarak nasil tutulacagi ile ilgili bir garanti vermez. Garantili olan, nesnelerin akis sirasinda yukaridan asagi olusturulup, cikista olusturulma sirasina ters yok edilecegidir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>void foo()
{
	std::string x;
	std::vector&lt;int&gt; ints;

	ints.push_back(5);
	float y = 3.5f;
}</pre>
</div>
</div>
<div class="paragraph">
<p>Yukaridaki ornekte sirayla <code>x</code> ve <code>ints</code> construct edilecek, <code>push_back</code> operasyonundan sonra da <code>y</code>'ye 3.5 degeri atanacak. <code>float</code> tipindeki nesnelerin destructor&#8217;u olmadigi icin, fonksyon cikisinda once <code>ints</code> sonra da <code>x</code> yok edilecek.</p>
</div>
<div class="paragraph">
<p>Bir fonksyonun icindeki tum nesneler, fonksyondan donus veya bir exception sebebiyle cikildiginda yok edilir ve butun bu nesnelerle ilgili iterator ve pointer&#8217;lar <em>gecersizlenir</em>.</p>
</div>
<div class="paragraph">
<p><code>auto</code> keyword&#8217;u eskiden bir local degiskenin automatic storage&#8217;a sahip oldugunu belirtmek icin kullaniliyordu. Sacma geliyorsa aramiza hosgeldiniz! Neyse ki gunumuzde cok daha anlamli bir ise yariyor.</p>
</div>
<div class="paragraph">
<p>Bir type icerisindeki uye nesneler de automatic storage semantiklerine sahiptir. Kisaca nesneleri, uye nesnelerini kapsayan bir <em>scope</em> olarak dusunebilirsiniz. Nesneye ait scope, nesne construct edildiginde baslar ve destruct edildiginde biter.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dynamic_storage">4. Dynamic storage</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ilk 3 storage tipinin tamaminin omru basladiktan sonra yok edildigi, dil tarafindan garantilenen <em>well defined</em> noktalar bulunuyor: automatic&#8217;ler icin scope bitisi, thread local ve static&#8217;ler icin de giris noktalarindan donus.</p>
</div>
<div class="paragraph">
<p>Dynamic storage icinse bu sekilde herhangi bir garanti bulunmuyor. Bu nesnelerin omru, memory allocation&#8217;dan sonra nesnenin construct edilmesiyle baslayip, tamamen dinamik sekilde, olustugu scope&#8217;tan bagimsiz olarak bitiyor.</p>
</div>
<div class="paragraph">
<p>Programciya nesne lifetime&#8217;i ile ilgili soz hakki veren tek kategori dynamic storage. Fakat bu soz hakki ile beraber, buyuk bir sorumluluk da geliyor: kaynak yonetimi. Ornegin automatic nesnelerin destructor&#8217;u otomatik cagirilip, atanan memory geri verilirken, dynamic nesneler icin bu gecerli degildir ve bunun nasil yapilacagi programciya birakilmistir. Allocate edilen memory&#8217;nin geri verilmemesi, nesnelerin yok edilmemesi yada daha kotusu bunlarin birden cok yapilmasi gibi problemler, dynamic storage kullanimindan olabildigince kacinmaya yonlendirmektedir.</p>
</div>
<div class="paragraph">
<p>Dynamic storage&#8217;a ait nesneler genellikle <code>new</code> operatoru ile alinsa da, verimlilik amaciyla ozel memory allocator&#8217;leri kullanarak da olusturulabilir. <code>malloc</code>/<code>free</code> sadece raw memory ile calistigi ve constructor/destruct cagirmadigi icin cok daha tehlikelidir ve modern C++ kodunda asla kullanilmamalidir. Raw memory ihtiyaciniz varsa, <code>malloc(N)</code> yerine, <code>new char[N]</code> kullanabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Tabi baska bir not olarak modern C++ kodunda genel olarak <code>new</code>/<code>delete</code> ile manuel olarak ugrasmayip RAII adi verilen bir teknik kullaniriz. Kisaca bu pattern dynamic lifetime&#8217;a sahip nesnelerin yonetimini automatic lifetime&#8217;a sahip nesnelere baglayarak, kaynaklarin otomatik olarak iade edilmesini saglar. Daha detayli bilgi icin mutlaka <a href="raii.html#title">RAII sayfasi</a>ni ziyaret edin!</p>
</div>
</div>
</div>
</div>
</body>
</html>