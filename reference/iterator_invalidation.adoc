= Iterator invalidation
Fatih BAKIR <bakir@ucsb.edu>

Iterator gecersizleme, omru bitmemis bir iterator'un gosterdigi nesnenin omrunun bitmesine denir. Gecersizlenmis iteratorlere _dangling_ iterator de denir.

Pointer'lar icin de ayni durum gecerli olmakla _dangling pointer_ belki de daha sik kullanilan bir terimdir.

[source]
----
void foo()
{
	auto x = new int;
	delete x;
	// x bu noktada gecersiz
}
----

Bu noktada onemli bir mevzu, {cpp}'da iterator ve pointerlarin gosterdigi nesneyi _takip etmiyor_ olusudur. Ustteki ornekte gecersizleme asikarken, daha gizli yollardan bu problemle karsilasabiliriz. Mesela `std::vector` gibi bitisik container tiplerinde eger alan onden `reserve` edilmemisse yeni bir eleman eklemek butun iteratorleri gecersizler:

[source]
----
void foo()
{
	std::vector v{3, 5, 7, 9}; // C++17 template type deduction

	auto it = v.begin() + 1;
}
----

Bu koda gore, asagidakine benzer bir memory durumuna sahipiz:

image::iterator_invalid1.png[State, width="80%", align="center"]

Fakat vector'ümüze aşağıdaki gibi bir eleman daha eklersek, olan bütün elemanlar vector büyüdükten sonraki yere 
taşınacak ve vector'ün orijinal yeri deallocate edilecek. Bu durumda, `it` hala vector'un eski elemanlarından birininin
bulunduğu yeri gösterdiği için, kendisine _sarkıyor_ yani _danglind_ diyoruz:

[source]
----
	v.push_back(11);
	// it bu noktada dangle etmekte
----

image::iterator_invalid2.png[State, width="80%", align="center"]
